# -*- coding: utf-8 -*-
"""Model

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DZxxYXeXwyiqRPa5YavOaA6gTCQibzlH
"""

import streamlit as st
import torch
import timm
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from PIL import Image
from transformers import pipeline, AutoImageProcessor, AutoModelForImageClassification
import time
import requests
from io import BytesIO
import json
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Set page config
st.set_page_config(
    page_title="Model Comparison: VGG19 vs ResNet-50",
    page_icon="ü§ñ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Title and description
st.title("ü§ñ Image Classification Model Comparison")
st.markdown("**Compare VGG19 and ResNet-50 models for image classification**")
st.markdown("---")

# Cache model loading to avoid reloading on every interaction
@st.cache_resource
def load_models():
    """Load both models with caching"""
    try:
        # Set device
        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

        # Load VGG19
        vgg19_model = timm.create_model("hf_hub:timm/vgg19.tv_in1k", pretrained=True)
        vgg19_model.eval()
        vgg19_model.to(device)

        # Get VGG19 data config
        vgg19_config = timm.data.resolve_model_data_config(vgg19_model)
        vgg19_transform = timm.data.create_transform(**vgg19_config, is_training=False)

        # Load ResNet-50
        resnet_pipe = pipeline("image-classification", model="microsoft/resnet-50",
                              device=0 if torch.cuda.is_available() else -1)

        # Load ImageNet classes
        imagenet_classes_url = "https://raw.githubusercontent.com/pytorch/hub/master/imagenet_classes.txt"
        response = requests.get(imagenet_classes_url)
        imagenet_classes = response.text.strip().split('\n')

        return {
            'vgg19_model': vgg19_model,
            'vgg19_transform': vgg19_transform,
            'resnet_pipe': resnet_pipe,
            'imagenet_classes': imagenet_classes,
            'device': device
        }
    except Exception as e:
        st.error(f"Error loading models: {str(e)}")
        return None

# Load models
with st.spinner("Loading models... This may take a few minutes."):
    models = load_models()

if models is None:
    st.error("Failed to load models. Please check your internet connection and try again.")
    st.stop()

# Sidebar
st.sidebar.header("Model Information")
st.sidebar.markdown("""
**VGG19 (Visual Geometry Group)**
- Architecture: 19 layers
- Parameters: ~144M
- Source: timm library
- Dataset: ImageNet-1k

**ResNet-50 (Residual Network)**
- Architecture: 50 layers
- Parameters: ~25.6M
- Source: Transformers library
- Dataset: ImageNet-1k
""")

st.sidebar.markdown("---")
st.sidebar.markdown("**Device Information**")
st.sidebar.info(f"Running on: {models['device']}")

# Prediction functions
def predict_vgg19(image, models):
    """Predict using VGG19 model"""
    start_time = time.time()

    # Preprocess image
    input_tensor = models['vgg19_transform'](image).unsqueeze(0).to(models['device'])

    # Inference
    with torch.no_grad():
        outputs = models['vgg19_model'](input_tensor)
        probabilities = torch.nn.functional.softmax(outputs[0], dim=0)

    # Get top 5 predictions
    top5_prob, top5_indices = torch.topk(probabilities, 5)

    inference_time = time.time() - start_time

    results = []
    for i in range(5):
        results.append({
            'class': models['imagenet_classes'][top5_indices[i].item()],
            'confidence': top5_prob[i].item(),
            'rank': i + 1
        })

    return results, inference_time

def predict_resnet50(image, models):
    """Predict using ResNet-50 model"""
    start_time = time.time()

    # Using pipeline for inference
    outputs = models['resnet_pipe'](image, top_k=5)

    inference_time = time.time() - start_time

    results = []
    for i, output in enumerate(outputs):
        results.append({
            'class': output['label'],
            'confidence': output['score'],
            'rank': i + 1
        })

    return results, inference_time

# Main content
col1, col2 = st.columns([1, 1])

with col1:
    st.header("üì§ Upload Image")
    uploaded_file = st.file_uploader("Choose an image...", type=['jpg', 'jpeg', 'png'])

    if uploaded_file is not None:
        # Display uploaded image
        image = Image.open(uploaded_file).convert('RGB')
        st.image(image, caption="Uploaded Image", use_container_width=True)

        # Add predict button
        if st.button("üîç Analyze Image", type="primary"):
            with st.spinner("Analyzing image with both models..."):
                # Get predictions from both models
                vgg_results, vgg_time = predict_vgg19(image, models)
                resnet_results, resnet_time = predict_resnet50(image, models)

                # Store results in session state
                st.session_state.vgg_results = vgg_results
                st.session_state.resnet_results = resnet_results
                st.session_state.vgg_time = vgg_time
                st.session_state.resnet_time = resnet_time

with col2:
    st.header("üîó Or Use Sample Images")
    sample_images = {
        "School Bus": "https://images.unsplash.com/photo-1544620347-c4fd4a3d5957?w=640&h=480&fit=crop&crop=center",
        "Cat": "https://images.unsplash.com/photo-1574158622682-e40e69881006?w=640&h=480&fit=crop&crop=center",
        "Mountain": "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=640&h=480&fit=crop&crop=center"
    }

    selected_sample = st.selectbox("Choose a sample image:", list(sample_images.keys()))

    if st.button("üñºÔ∏è Use Sample Image"):
        try:
            response = requests.get(sample_images[selected_sample])
            sample_image = Image.open(BytesIO(response.content)).convert('RGB')
            st.image(sample_image, caption=f"Sample Image: {selected_sample}", use_container_width=True)

            # Auto-analyze sample image
            with st.spinner("Analyzing sample image..."):
                vgg_results, vgg_time = predict_vgg19(sample_image, models)
                resnet_results, resnet_time = predict_resnet50(sample_image, models)

                # Store results in session state
                st.session_state.vgg_results = vgg_results
                st.session_state.resnet_results = resnet_results
                st.session_state.vgg_time = vgg_time
                st.session_state.resnet_time = resnet_time
        except Exception as e:
            st.error(f"Error loading sample image: {str(e)}")

# Display results if available
if hasattr(st.session_state, 'vgg_results') and hasattr(st.session_state, 'resnet_results'):
    st.markdown("---")
    st.header("üìä Comparison Results")

    # Performance metrics
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric("VGG19 Inference Time", f"{st.session_state.vgg_time:.3f}s")

    with col2:
        st.metric("ResNet-50 Inference Time", f"{st.session_state.resnet_time:.3f}s")

    with col3:
        speed_diff = ((st.session_state.vgg_time - st.session_state.resnet_time) / st.session_state.resnet_time) * 100
        st.metric("Speed Difference", f"{speed_diff:+.1f}%")

    with col4:
        conf_diff = (st.session_state.vgg_results[0]['confidence'] - st.session_state.resnet_results[0]['confidence']) * 100
        st.metric("Confidence Difference", f"{conf_diff:+.1f}%")

    # Detailed predictions
    col1, col2 = st.columns(2)

    with col1:
        st.subheader("üü¶ VGG19 Predictions")
        vgg_df = pd.DataFrame(st.session_state.vgg_results)
        vgg_df['confidence'] = vgg_df['confidence'].apply(lambda x: f"{x:.4f}")
        st.dataframe(vgg_df, use_container_width=True)

    with col2:
        st.subheader("üü® ResNet-50 Predictions")
        resnet_df = pd.DataFrame(st.session_state.resnet_results)
        resnet_df['confidence'] = resnet_df['confidence'].apply(lambda x: f"{x:.4f}")
        st.dataframe(resnet_df, use_container_width=True)

    # Visualization
    st.subheader("üìà Confidence Comparison")

    # Create comparison chart
    fig = make_subplots(
        rows=1, cols=2,
        subplot_titles=('VGG19 Top 5 Predictions', 'ResNet-50 Top 5 Predictions'),
        specs=[[{"secondary_y": False}, {"secondary_y": False}]]
    )

    # VGG19 bar chart
    vgg_classes = [result['class'] for result in st.session_state.vgg_results]
    vgg_confidences = [result['confidence'] for result in st.session_state.vgg_results]

    fig.add_trace(
        go.Bar(x=vgg_classes, y=vgg_confidences, name="VGG19", marker_color="lightblue"),
        row=1, col=1
    )

    # ResNet-50 bar chart
    resnet_classes = [result['class'] for result in st.session_state.resnet_results]
    resnet_confidences = [result['confidence'] for result in st.session_state.resnet_results]

    fig.add_trace(
        go.Bar(x=resnet_classes, y=resnet_confidences, name="ResNet-50", marker_color="lightcoral"),
        row=1, col=2
    )

    fig.update_layout(height=400, showlegend=False)
    fig.update_xaxes(tickangle=45)
    fig.update_yaxes(title_text="Confidence", range=[0, 1])

    st.plotly_chart(fig, use_container_width=True)

    # Performance comparison chart
    st.subheader("‚ö° Performance Comparison")

    perf_data = pd.DataFrame({
        'Model': ['VGG19', 'ResNet-50'],
        'Inference Time (s)': [st.session_state.vgg_time, st.session_state.resnet_time],
        'Top-1 Confidence': [st.session_state.vgg_results[0]['confidence'],
                           st.session_state.resnet_results[0]['confidence']]
    })

    col1, col2 = st.columns(2)

    with col1:
        fig_time = px.bar(perf_data, x='Model', y='Inference Time (s)',
                         color='Model', title="Inference Time Comparison")
        st.plotly_chart(fig_time, use_container_width=True)

    with col2:
        fig_conf = px.bar(perf_data, x='Model', y='Top-1 Confidence',
                         color='Model', title="Top-1 Confidence Comparison")
        st.plotly_chart(fig_conf, use_container_width=True)

# Footer
st.markdown("---")
st.markdown("""
**About this application:**
- Built with Streamlit for easy deployment
- Uses timm library for VGG19 and Transformers library for ResNet-50
- Compares inference time and prediction confidence
- Supports both uploaded images and sample images

**Created for model comparison and educational purposes**
""")

# Additional information in expander
with st.expander("‚ÑπÔ∏è Technical Details"):
    st.markdown("""
    **Model Architectures:**

    **VGG19:**
    - 19 layers (16 convolutional + 3 fully connected)
    - Uses 3x3 convolution filters
    - Deeper but simpler architecture
    - Higher parameter count (~144M)

    **ResNet-50:**
    - 50 layers with residual connections
    - Uses skip connections to prevent vanishing gradients
    - More efficient architecture
    - Lower parameter count (~25.6M)

    **Performance Factors:**
    - Inference time depends on model complexity and hardware
    - Confidence scores may vary based on training data and architecture
    - Both models are trained on ImageNet dataset
    """)

# Error handling
if st.button("üîÑ Reset Application"):
    for key in ['vgg_results', 'resnet_results', 'vgg_time', 'resnet_time']:
        if key in st.session_state:
            del st.session_state[key]
    st.rerun()
